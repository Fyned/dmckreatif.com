{
  "services": {
    "reactDev": {
      "title": "REACT DEVELOPMENT",
      "desc": "Custom React applications with component-based architecture, hooks, and modern state management. We build fast, scalable single-page applications tailored to European businesses.",
      "longDesc": "React is the most widely adopted frontend library in the world, and for good reason. At DMC Kreatif, we leverage React 18 to build component-driven applications that scale from a simple landing page to a complex enterprise dashboard. Our React development goes beyond basic implementation -- we architect applications with reusable component libraries, custom hooks, and clean state management using Zustand or React Context, ensuring your codebase remains maintainable as your business grows.\n\nOur development process is rooted in performance engineering. We implement code splitting with React.lazy and Suspense boundaries so users only download the JavaScript they need. Server components, where applicable, reduce client-side bundle sizes. We optimize re-renders through careful memoization with useMemo and useCallback, and we profile every application using React DevTools to eliminate unnecessary renders. The result is applications that consistently score 95+ on Google Lighthouse.\n\nFor European businesses, we build React applications with multilingual support baked into the architecture from day one. Using i18next, we implement locale-based routing, RTL support where needed, and dynamic content loading per language. This means your French customers see content in French with proper date formatting, currency display, and culturally appropriate layouts -- not just translated strings. We handle hreflang tags, localized URLs, and language-specific SEO metadata automatically.\n\nOur React stack includes TypeScript for compile-time type safety, Tailwind CSS for consistent and responsive styling, Framer Motion for fluid animations, and Radix UI for accessible primitive components. We integrate with backends via Supabase, REST APIs, or GraphQL, and deploy to Vercel, Hostinger, or your preferred infrastructure. Every project includes automated testing, CI/CD pipeline configuration, and comprehensive documentation so your team can maintain the codebase independently.",
      "f1": "Component-based architecture with reusable UI library and design system",
      "f2": "React 18 with hooks, Suspense, and concurrent rendering features",
      "f3": "State management using Zustand, React Context, or Redux Toolkit",
      "f4": "Code splitting and lazy loading for optimized bundle sizes",
      "f5": "Multilingual support with i18next and locale-based routing",
      "f6": "Integration with Supabase, REST APIs, or GraphQL backends",
      "f7": "Automated testing with Vitest and React Testing Library",
      "f8": "CI/CD pipeline setup with GitHub Actions and automated deployments",
      "step1": "Architecture planning: we define component structure, state management strategy, routing, and API integration patterns based on your requirements.",
      "step2": "Component development: we build reusable UI components with TypeScript types, accessibility attributes, and responsive behavior across all breakpoints.",
      "step3": "Integration and optimization: connecting frontend to your backend services, implementing data fetching patterns, caching, and performance profiling.",
      "step4": "Testing, deployment, and handover: comprehensive test coverage, production build optimization, deployment to your infrastructure, and developer documentation."
    },
    "nextjsDev": {
      "title": "NEXT.JS DEVELOPMENT",
      "desc": "Server-side rendered and statically generated websites with Next.js App Router. SEO-optimized, blazing-fast web applications with ISR and API routes for European markets.",
      "longDesc": "Next.js is the production framework for React, and it is our choice for projects where SEO, performance, and scalability are non-negotiable. We build with the Next.js 14 App Router, leveraging server components, streaming SSR, and incremental static regeneration (ISR) to deliver pages that load instantly and rank exceptionally well on Google. For European businesses competing in crowded markets like web design in Paris or accounting services in London, the SEO advantage of server-rendered content is a measurable competitive edge.\n\nOur Next.js expertise covers the full spectrum of rendering strategies. We use static generation (SSG) for marketing pages and blog posts that rarely change, server-side rendering (SSR) for dynamic content like user dashboards and e-commerce product pages, and ISR for content that updates periodically -- such as pricing pages or portfolio entries. This hybrid approach means each page uses the optimal rendering strategy for its specific use case, balancing performance with data freshness.\n\nWe build Next.js API routes and server actions to handle backend logic without a separate server. Form submissions, webhook handlers, authentication flows, and third-party API proxies all run as serverless functions at the edge, deployed close to your European users for minimal latency. For more complex backends, we integrate with Supabase for database operations, authentication, and file storage, giving you a full-stack application from a single codebase.\n\nEvery Next.js project we deliver includes proper internationalization using the App Router's built-in i18n routing, OpenGraph and Twitter Card metadata for social sharing, JSON-LD structured data for rich search results, and automated sitemap generation. We configure middleware for locale detection, implement proper redirect chains for SEO migrations, and set up analytics with consent-mode-compliant GA4 integration. The result is a website that is fast, discoverable, and compliant with European regulations.",
      "f1": "Next.js 14 App Router with server and client components",
      "f2": "Static generation, SSR, and incremental static regeneration (ISR)",
      "f3": "API routes and server actions for backend logic at the edge",
      "f4": "Built-in internationalization with locale-based routing",
      "f5": "Automated sitemap, OpenGraph metadata, and JSON-LD schemas",
      "f6": "Image optimization with next/image and responsive breakpoints",
      "f7": "Middleware for authentication, redirects, and locale detection",
      "f8": "Deployment to Vercel with preview environments for every PR",
      "step1": "Requirements analysis: we map your pages, data sources, and rendering needs to determine the optimal SSG/SSR/ISR strategy for each route.",
      "step2": "Architecture and design: building the page structure, layout system, shared components, and data fetching layer with server components.",
      "step3": "Full-stack development: implementing pages, API routes, authentication, CMS integration, and multilingual content with proper SEO metadata.",
      "step4": "Performance audit, Lighthouse testing, deployment to Vercel or self-hosted infrastructure, and knowledge transfer with documentation."
    },
    "typescriptDev": {
      "title": "TYPESCRIPT DEVELOPMENT",
      "desc": "Type-safe development with TypeScript strict mode, reducing runtime bugs by up to 40% and improving long-term maintainability for enterprise-grade European web applications.",
      "longDesc": "TypeScript transforms JavaScript from a loosely typed scripting language into a robust, enterprise-grade development platform. At DMC Kreatif, every project we build uses TypeScript in strict mode -- this is not optional. Strict mode catches null pointer exceptions, type mismatches, and implicit any types at compile time, before your users ever encounter them. Studies from Microsoft and Airbnb show that TypeScript adoption reduces production bugs by 15-40%, and our own experience confirms this across dozens of European client projects.\n\nOur TypeScript development goes far beyond adding type annotations to JavaScript files. We design comprehensive type systems that model your business domain accurately. For an e-commerce client, this means typed product catalogs, cart operations, and checkout flows where the compiler verifies that a product with options cannot be added to cart without selecting those options. For a multilingual site, our type system ensures every i18n key exists in all supported languages at compile time, eliminating missing translation errors entirely.\n\nWe leverage advanced TypeScript features including discriminated unions for state machines, generic utility types for API response handling, Zod schemas that generate runtime validators from TypeScript types, and type-safe routing with inferred path parameters. Our API integrations use generated types from OpenAPI specifications or GraphQL codegen, so your frontend and backend contracts are always in sync. When a backend developer changes an API field, TypeScript immediately flags every affected frontend component.\n\nFor teams inheriting or maintaining the codebase, TypeScript serves as living documentation. Every function signature, component prop, and API response is explicitly typed with JSDoc comments where additional context helps. We configure ESLint with typescript-eslint rules, set up pre-commit hooks that prevent type errors from reaching your repository, and integrate type checking into your CI/CD pipeline. The result is a codebase that new developers can understand and modify with confidence, reducing onboarding time from weeks to days.",
      "f1": "TypeScript strict mode with comprehensive type coverage across the codebase",
      "f2": "Domain-specific type modeling for your business logic and data structures",
      "f3": "Zod schema validation generating runtime validators from TypeScript types",
      "f4": "API type generation from OpenAPI specs or GraphQL codegen",
      "f5": "Generic utility types for consistent error handling and API responses",
      "f6": "ESLint with typescript-eslint rules and pre-commit type checking",
      "f7": "Type-safe i18n ensuring all translation keys exist in every language",
      "f8": "Comprehensive JSDoc documentation and developer onboarding guides",
      "step1": "Type architecture design: we define the domain model, API contracts, shared types, and validation schemas before writing application code.",
      "step2": "Implementation with strict mode: building components, hooks, and services with full type coverage and zero any types in the codebase.",
      "step3": "Integration testing: verifying type contracts between frontend and backend, running compile-time checks and runtime validation in CI/CD.",
      "step4": "Documentation and handover: type system documentation, developer guides, ESLint configuration, and team training on TypeScript best practices."
    },
    "frontendDev": {
      "title": "FRONTEND DEVELOPMENT",
      "desc": "Modern frontend architecture with responsive design, WCAG accessibility, and performance optimization. Pixel-perfect interfaces built with React, TypeScript, and Tailwind CSS.",
      "longDesc": "Frontend development is where design meets engineering, and getting it right requires mastery of both disciplines. We build frontends that are not just visually polished but technically excellent -- responsive across every breakpoint from 320px mobile screens to 2560px ultrawide displays, accessible to users with disabilities, and fast enough to pass Core Web Vitals on real-world 3G connections. Our frontend team combines design sensibility with deep technical knowledge of browser rendering, CSS layout algorithms, and JavaScript performance.\n\nOur responsive implementation goes beyond media queries. We use CSS clamp() for fluid typography that scales smoothly between breakpoints, CSS Grid and Flexbox for layouts that adapt intelligently to available space, and container queries for components that respond to their parent's size rather than the viewport. Every interactive element has appropriate touch targets (minimum 44x44px per WCAG guidelines), and we test on actual devices -- not just browser dev tools -- to catch issues like iOS Safari viewport quirks, Android Chrome scroll behavior, and landscape orientation edge cases.\n\nAccessibility is embedded in our development process, not bolted on as an afterthought. We use semantic HTML elements, ARIA attributes where native semantics are insufficient, focus management for modals and dynamic content, and screen reader testing with NVDA and VoiceOver. Our components meet WCAG 2.1 AA standards, which is increasingly important for European businesses as the European Accessibility Act (EAA) takes effect in 2025, requiring digital services to be accessible. Non-compliance carries significant financial penalties in EU member states.\n\nPerformance optimization starts at the component level. We implement virtualized lists for large datasets, intersection observer for lazy loading, optimistic UI updates for perceived speed, and skeleton screens during data fetching. CSS is optimized with Tailwind's purge system, eliminating unused styles. Images use modern formats (WebP, AVIF) with responsive srcsets. Fonts are subset to include only the characters your content needs. The cumulative result is a frontend that feels instant and responsive, even on slower European mobile networks.",
      "f1": "Responsive design tested on real devices across all breakpoints",
      "f2": "WCAG 2.1 AA accessibility compliance with screen reader testing",
      "f3": "Fluid typography and spacing using CSS clamp() functions",
      "f4": "CSS Grid and Flexbox layouts with container query support",
      "f5": "Performance-optimized images in WebP/AVIF with responsive srcsets",
      "f6": "Smooth animations with Framer Motion and reduced-motion support",
      "f7": "Cross-browser testing on Chrome, Firefox, Safari, and Edge",
      "f8": "Mobile-first development with touch-optimized interactions",
      "step1": "Design analysis: we review designs at every breakpoint, identify interactive patterns, accessibility requirements, and performance-critical sections.",
      "step2": "Component architecture: building a design system with accessible, responsive components using Tailwind CSS and Radix UI primitives.",
      "step3": "Page integration: assembling pages from components, implementing data fetching, animations, form validation, and cross-browser testing.",
      "step4": "Performance audit: Lighthouse profiling, bundle analysis, image optimization, and accessibility testing with automated and manual tools."
    },
    "customApps": {
      "title": "CUSTOM WEB APPLICATIONS",
      "desc": "Bespoke web applications built to your exact business requirements. Dashboards, client portals, SaaS platforms, and internal tools for European enterprises.",
      "longDesc": "Off-the-shelf software forces your business to adapt to its limitations. Custom web applications work the other way around -- they are built to match your specific workflows, data structures, and business rules. At DMC Kreatif, we develop bespoke web applications for European businesses that need more than a website: client portals where your customers track orders and invoices, internal dashboards that aggregate data from multiple sources, SaaS platforms that become revenue-generating products, and workflow automation tools that eliminate manual processes.\n\nOur application architecture is designed for reliability and scale. We use Supabase as our primary backend platform, providing PostgreSQL database with row-level security, real-time subscriptions for live data updates, edge functions for serverless business logic, and built-in authentication with social login providers. For applications that need more complex backend processing, we build Node.js microservices deployed as containerized workloads. Every application includes proper error boundaries, retry logic, and graceful degradation so your business operations continue even when third-party services experience outages.\n\nSecurity is paramount for applications handling business data. We implement role-based access control (RBAC) so administrators, managers, and regular users see only what they should. All data is encrypted in transit and at rest. API endpoints are protected with rate limiting, input validation using Zod schemas, and CSRF protection. For applications processing personal data of European users, we ensure full GDPR compliance including data export functionality, right-to-deletion workflows, and audit logging of data access. We conduct security reviews using OWASP guidelines before every production deployment.\n\nWe build custom applications iteratively, delivering functional increments every two weeks. You get a working application early -- not a wireframe or a prototype, but actual software you can use and test with real data. Each sprint adds features based on prioritized requirements, and we adjust course based on your feedback. This approach reduces risk, surfaces issues early, and ensures the final application truly fits your business needs rather than an outdated specification document.",
      "f1": "Bespoke architecture tailored to your specific business workflows",
      "f2": "Role-based access control with admin, manager, and user tiers",
      "f3": "Real-time data updates with Supabase subscriptions and WebSockets",
      "f4": "Dashboard and reporting modules with data visualization charts",
      "f5": "Document upload, processing, and storage with Supabase Storage",
      "f6": "Email and notification system for alerts and user communications",
      "f7": "GDPR-compliant data handling with export and deletion workflows",
      "f8": "API integrations with your existing tools (CRM, ERP, accounting)",
      "step1": "Discovery workshop: mapping your business processes, user roles, data flows, and integration requirements into a detailed technical specification.",
      "step2": "Architecture design: database schema, API contracts, authentication flow, and deployment infrastructure decisions documented and approved.",
      "step3": "Iterative development: two-week sprints delivering functional features, with demo sessions and feedback loops after each sprint.",
      "step4": "Launch, training, and support: production deployment, user training sessions, admin documentation, and ongoing maintenance agreement."
    },
    "pwa": {
      "title": "PROGRESSIVE WEB APPS",
      "desc": "Offline-capable, installable web applications with push notifications and app-like experience. Reach users on any device without app store distribution costs.",
      "longDesc": "Progressive Web Apps bridge the gap between websites and native mobile applications, and for many European businesses, they are the smarter choice. A PWA loads like a website, installs like an app, works offline, and sends push notifications -- all without the 30% commission Apple and Google charge on app store transactions, and without maintaining separate iOS and Android codebases. We build PWAs that provide genuine app-like experiences: smooth 60fps animations, gesture navigation, camera access, and background sync.\n\nOur PWA implementation starts with the service worker -- the technology that makes offline functionality possible. We configure intelligent caching strategies using Workbox: cache-first for static assets like images and fonts, stale-while-revalidate for API responses that benefit from freshness, and network-first for real-time data. The result is an application that loads instantly from cache on repeat visits, works during network interruptions (critical for users on European trains or in areas with spotty coverage), and updates seamlessly in the background when connectivity returns.\n\nPush notifications are one of the most powerful PWA features for business engagement. We implement the Web Push API with proper permission flows that respect user preferences, segment-based targeting so you can notify specific user groups, and rich notification payloads with images and action buttons. For European businesses, we ensure notifications comply with GDPR consent requirements -- users must explicitly opt in, and we provide clear unsubscribe mechanisms. Our notification infrastructure uses web push protocols that work across Chrome, Firefox, Edge, and Safari (from version 16.4).\n\nThe install experience is designed to feel natural. We configure the web app manifest with appropriate icons, splash screens, display modes, and theme colors. We implement custom install prompts that appear at contextually appropriate moments -- after a user has engaged with the app, not on first visit. Once installed, the PWA appears on the home screen alongside native apps, opens without browser chrome, and behaves identically to a native application. For businesses serving multiple European markets, the PWA automatically adapts its language, currency, and content based on the user's locale.",
      "f1": "Service worker with intelligent Workbox caching for offline support",
      "f2": "Web app manifest with custom icons, splash screens, and theme",
      "f3": "Push notifications with GDPR-compliant opt-in and segmentation",
      "f4": "Background sync for data submitted while offline",
      "f5": "App-like navigation with 60fps animations and gesture support",
      "f6": "Automatic updates with versioned service worker lifecycle management",
      "f7": "Device API access: camera, geolocation, and local storage",
      "f8": "Custom install prompts with contextual timing for higher adoption",
      "step1": "Feasibility assessment: evaluating which native features your app needs and confirming PWA can deliver them across target browsers and devices.",
      "step2": "Architecture design: defining caching strategies, offline data model, push notification infrastructure, and install experience flow.",
      "step3": "Development: building the PWA shell, service worker, offline pages, push notification system, and testing across Chrome, Safari, and Firefox.",
      "step4": "Launch and monitoring: deploying with HTTPS, configuring lighthouse PWA audit, setting up analytics for install rates and offline usage."
    },
    "apiDev": {
      "title": "API DEVELOPMENT",
      "desc": "RESTful and GraphQL APIs, serverless edge functions, and third-party integrations. Secure, documented, and scalable backend services for European businesses.",
      "longDesc": "APIs are the backbone of modern web applications, connecting your frontend to databases, third-party services, and business logic. We design and build APIs that are secure, performant, and documented well enough that any developer can integrate with them. Whether you need a RESTful API for a mobile app, a GraphQL API for a complex frontend, or serverless edge functions for lightweight backend processing, we architect the solution that fits your specific requirements and budget.\n\nOur primary API platform is Supabase, which provides auto-generated RESTful APIs from your PostgreSQL schema, real-time subscriptions via WebSockets, and edge functions for custom business logic. This approach dramatically reduces development time -- your API is ready to use the moment you define your database tables, with row-level security policies controlling who can access what data. For more complex requirements, we build custom Node.js APIs with Express or Fastify, deployed as serverless functions on Vercel or as containerized services on your preferred infrastructure.\n\nAPI security is non-negotiable, especially for European businesses handling personal data. We implement JWT-based authentication with refresh token rotation, API key management for service-to-service communication, rate limiting to prevent abuse, input validation on every endpoint using Zod schemas, and comprehensive request logging for audit trails. For APIs that process EU citizen data, we ensure compliance with GDPR Article 32 requirements: encryption in transit (TLS 1.3), encryption at rest, access controls, and the ability to trace data access for subject access requests.\n\nEvery API we build comes with interactive documentation generated from the code. We use OpenAPI 3.0 specifications with Swagger UI for REST APIs and GraphQL Playground for GraphQL APIs. Documentation includes example requests, response schemas, error codes, authentication instructions, and rate limit details. We also generate TypeScript client SDKs so your frontend team has type-safe API calls from day one. Versioning strategies (URL-based or header-based) ensure existing integrations are never broken when the API evolves.",
      "f1": "RESTful API design following OpenAPI 3.0 specification standards",
      "f2": "GraphQL APIs with code-generated TypeScript types and resolvers",
      "f3": "Supabase edge functions for serverless business logic at the edge",
      "f4": "JWT authentication with refresh token rotation and session management",
      "f5": "Rate limiting, input validation, and CORS configuration",
      "f6": "Interactive API documentation with Swagger UI or GraphQL Playground",
      "f7": "Webhook endpoints for receiving events from third-party services",
      "f8": "TypeScript SDK generation for type-safe frontend integration",
      "step1": "API design: defining endpoints, data models, authentication flow, error handling patterns, and versioning strategy in an OpenAPI specification.",
      "step2": "Implementation: building endpoints with validation, authentication middleware, database queries, and business logic with comprehensive error handling.",
      "step3": "Testing and security review: automated integration tests, load testing, security audit for OWASP top 10, and GDPR compliance verification.",
      "step4": "Documentation and deployment: interactive API docs, TypeScript SDK, deployment to production, and monitoring with alerting for errors and latency."
    },
    "redesign": {
      "title": "WEBSITE REDESIGN",
      "desc": "Modernize your existing website with better UX, faster performance, improved mobile experience, and stronger SEO. Transform outdated sites into conversion machines.",
      "longDesc": "A website redesign is not just a visual refresh -- it is a strategic investment in your digital presence. Most European businesses we work with come to us because their existing site loads slowly on mobile, looks outdated compared to competitors, fails to generate leads, or does not rank well on Google. Our redesign process addresses all of these issues systematically, starting with data analysis of your current site's performance, user behavior, and conversion bottlenecks before making any design decisions.\n\nWe begin every redesign project with a comprehensive audit. Using Google Analytics, Search Console, Hotjar heatmaps, and Lighthouse, we identify exactly where your current site fails: which pages have high bounce rates, where users abandon forms, what content gets ignored, and which technical issues hurt your search rankings. This data-driven approach ensures we are redesigning based on evidence, not assumptions. We also audit your competitors to identify design patterns and features your market expects.\n\nThe migration process is handled with extreme care for SEO continuity. We map every existing URL to its new location, implement 301 redirects for pages that move or merge, preserve inbound link equity, and submit updated sitemaps to Google. We have seen too many businesses lose 40-60% of their organic traffic after a poorly executed redesign because redirects were missed or page content was changed without keyword consideration. Our migration checklist covers 87 items specifically to prevent traffic loss during the transition.\n\nThe redesigned site is built from scratch using modern technology -- React or Next.js with Tailwind CSS -- not by tweaking the old codebase. You get a fresh, fast, accessible website with modern UX patterns: clear visual hierarchy, intuitive navigation, compelling calls to action, and a mobile experience that feels native rather than a shrunk desktop layout. We A/B test critical pages during the transition period to verify the new design actually improves conversion rates before fully committing to the changes.",
      "f1": "Comprehensive UX and performance audit of your existing website",
      "f2": "Competitor analysis and modern design benchmark research",
      "f3": "Complete 301 redirect mapping to preserve SEO equity",
      "f4": "Conversion-focused redesign with clear CTAs and user journeys",
      "f5": "Mobile-first responsive design for all devices and screen sizes",
      "f6": "Content migration and optimization for improved readability",
      "f7": "Analytics setup with before/after performance benchmarking",
      "f8": "Post-launch monitoring to catch and resolve any traffic drops",
      "step1": "Site audit: comprehensive analysis of current performance, user behavior, SEO health, accessibility, and conversion metrics with a detailed findings report.",
      "step2": "Strategy and design: information architecture, wireframes, and visual design based on audit findings, competitor research, and your business objectives.",
      "step3": "Development and migration: building the new site, migrating content, implementing 301 redirects, and setting up analytics with conversion tracking.",
      "step4": "Launch and verification: staged rollout, SEO monitoring for traffic continuity, performance benchmarks, and two weeks of intensive post-launch support."
    },
    "legacyMod": {
      "title": "LEGACY MODERNIZATION",
      "desc": "Migrate from outdated technologies like jQuery, WordPress, or PHP to a modern React and Next.js stack. Zero-downtime migration with preserved SEO equity.",
      "longDesc": "Legacy websites built on jQuery, WordPress themes, or custom PHP are increasingly expensive to maintain and impossible to scale. Developers who understand these older codebases are harder to find, security patches lag behind, performance suffers from bloated plugins, and the user experience falls behind modern expectations. Our legacy modernization service provides a structured path from your outdated technology to a modern React or Next.js application -- without disrupting your business operations or losing your search engine rankings during the transition.\n\nOur migration approach varies based on your specific situation. For WordPress sites, we typically extract content via the REST API or WPGraphQL, rebuild the frontend in React or Next.js, and either keep WordPress as a headless CMS for content editors or migrate to a modern CMS like Payload CMS. For jQuery-based custom sites, we audit the existing functionality, identify business-critical features, and rebuild them as React components with proper state management. For PHP applications, we design a new API layer and frontend, migrating database schemas and business logic systematically.\n\nThe most critical aspect of any migration is continuity. We use a strangler fig pattern for complex migrations -- new features are built in the modern stack while the legacy system continues running, and traffic is gradually shifted to the new application page by page. This means zero downtime: your customers never see an \"under construction\" page, and your SEO rankings are preserved because URLs remain accessible throughout the transition. Each migrated section is tested thoroughly before it replaces its legacy counterpart.\n\nBeyond the technical migration, we address the accumulated technical debt that legacy systems inevitably carry. Hardcoded strings become i18n-ready content. Inline styles become a consistent design system. Untyped data flows become TypeScript interfaces. Manual deployments become automated CI/CD pipelines. The result is not just a new frontend -- it is a fundamentally healthier codebase that costs less to maintain, loads faster for users, and gives your development team a modern platform to build on for years to come.",
      "f1": "WordPress to headless CMS migration with content preservation",
      "f2": "jQuery to React component migration with equivalent functionality",
      "f3": "PHP backend modernization to Node.js or serverless architecture",
      "f4": "Strangler fig pattern for zero-downtime incremental migration",
      "f5": "Database schema migration and data integrity verification",
      "f6": "URL mapping and 301 redirects for complete SEO preservation",
      "f7": "Automated CI/CD pipeline replacing manual deployment processes",
      "f8": "Technical debt elimination: typing, testing, and documentation",
      "step1": "Legacy audit: comprehensive analysis of your current stack, dependencies, security vulnerabilities, performance issues, and feature inventory.",
      "step2": "Migration strategy: deciding between big-bang and incremental approaches, defining the target architecture, and creating a detailed migration roadmap.",
      "step3": "Incremental migration: building the new application module by module, testing each section, and gradually shifting traffic from legacy to modern stack.",
      "step4": "Decommission and cleanup: removing legacy infrastructure, verifying all redirects, running regression tests, and documenting the new architecture."
    },
    "maintenance": {
      "title": "MAINTENANCE & SUPPORT",
      "desc": "Ongoing website maintenance, security updates, performance monitoring, content updates, and priority technical support. Monthly care plans starting at EUR 97/month.",
      "longDesc": "A website is not a one-time project -- it is a living digital asset that requires ongoing attention. Security vulnerabilities in npm packages are discovered weekly. Browser vendors ship updates that can break CSS layouts. Google changes its ranking algorithms multiple times per year. Without proactive maintenance, your site degrades over time: performance drops, security holes open, and search rankings slip. Our maintenance and support plans ensure your website stays fast, secure, and effective long after launch.\n\nOur standard care plan includes weekly dependency updates with compatibility testing before deployment, monthly security scans for known vulnerabilities (CVEs) in your JavaScript packages, uptime monitoring with instant alerts if your site goes down, automated daily backups to a separate cloud storage location, and monthly performance reports showing Lighthouse scores, Core Web Vitals, and traffic trends. We handle everything proactively -- you do not need to think about server updates or security patches.\n\nContent updates are included in every care plan. Need to change your pricing, add a team member photo, update your portfolio with a new project, or modify your business hours? Simply send us the changes via email and they are live within one business day. For businesses with frequent content needs, we provide access to a content management dashboard where you can edit text and images directly, with our team reviewing changes before they go live to ensure nothing breaks.\n\nPriority technical support means you are never stuck waiting. Our care plan clients get a dedicated support channel with a 4-hour response time guarantee during business hours. Whether it is a broken form, a display issue on a specific device, or a question about Google Analytics data, you get expert help quickly. We also perform quarterly strategy reviews where we analyze your site's performance data and recommend improvements -- from new features that could improve conversions to SEO opportunities we have identified. Many of our maintenance clients see their organic traffic grow 20-40% year over year through these incremental optimizations.",
      "f1": "Weekly dependency updates with compatibility testing before deployment",
      "f2": "Monthly security vulnerability scans and immediate patch deployment",
      "f3": "Uptime monitoring with instant alerts and 99.9% SLA guarantee",
      "f4": "Automated daily backups with one-click restore capability",
      "f5": "Content updates within one business day via email request",
      "f6": "Monthly performance reports with Lighthouse and traffic analysis",
      "f7": "Priority support with 4-hour response time during business hours",
      "f8": "Quarterly strategy review with optimization recommendations",
      "step1": "Onboarding: we audit your current hosting, deployment process, and codebase health. Then we set up monitoring, backups, and support channels.",
      "step2": "Regular maintenance: weekly dependency updates, security patches, and performance checks. Monthly reports delivered to your inbox automatically.",
      "step3": "Content and feature updates: changes requested via email or support channel are implemented, tested, and deployed within agreed timeframes.",
      "step4": "Quarterly review: in-depth analysis of site performance, SEO trends, and user behavior with actionable recommendations for continuous improvement."
    },
    "headlessCms": {
      "title": "HEADLESS CMS",
      "desc": "Decoupled CMS solutions with Payload CMS, Strapi, or Contentful. Give your editors a powerful content management interface while maintaining a developer-grade React frontend.",
      "longDesc": "Traditional CMS platforms like WordPress couple your content with your presentation layer, limiting design freedom and creating performance bottlenecks. A headless CMS decouples these concerns: your editors get a familiar, powerful content management interface, while your developers have complete freedom to build the frontend with React, Next.js, or any modern framework. The CMS delivers content via API, and the frontend renders it however you need -- on a website, mobile app, digital signage, or any other channel.\n\nOur primary headless CMS recommendation is Payload CMS v3, an open-source, self-hosted solution built with TypeScript and React. Unlike SaaS platforms like Contentful or Sanity that charge per-seat or per-API-call fees that scale with your usage, Payload is self-hosted on your own infrastructure with no recurring platform fees. For European businesses concerned about data sovereignty -- particularly those in France and Germany with strict data residency requirements -- self-hosted Payload ensures your content data never leaves your chosen EU data center.\n\nWe configure Payload CMS with rich content modeling: collections for structured content (products, team members, projects), globals for site-wide settings (navigation, footer, SEO defaults), blocks for flexible page building (allowing editors to compose pages from pre-designed sections), and media management with automatic image optimization. Access control is configured per collection and per field, so intern editors cannot accidentally modify published pages while senior editors have full access. Version history and draft/publish workflows ensure content changes are reviewed before going live.\n\nThe frontend integration uses type-safe API calls generated from your CMS schema. When an editor publishes a blog post in Payload, the Next.js frontend receives a webhook and regenerates the affected page via incremental static regeneration -- the change is live within seconds without a full site rebuild. For high-traffic pages, we implement stale-while-revalidate caching strategies that serve cached content instantly while fetching fresh data in the background. The result is a content management experience that rivals WordPress for editors while delivering the performance and developer experience of a modern React application.",
      "f1": "Payload CMS v3 setup with custom collections and content models",
      "f2": "Rich text editor with embedded media, links, and custom blocks",
      "f3": "Draft/publish workflow with version history and rollback capability",
      "f4": "Role-based editor access control at collection and field level",
      "f5": "Automatic image optimization and responsive image generation",
      "f6": "Webhook-triggered ISR for near-instant content updates on the frontend",
      "f7": "Self-hosted deployment on EU infrastructure for data sovereignty",
      "f8": "Localization support for managing content in multiple languages",
      "step1": "Content audit: mapping your existing content types, editorial workflows, and team permissions to design the optimal CMS schema and access model.",
      "step2": "CMS configuration: setting up Payload CMS with collections, globals, blocks, media handling, and localization for your content languages.",
      "step3": "Frontend integration: connecting the CMS to your React or Next.js frontend with type-safe API calls, ISR, and preview mode for editors.",
      "step4": "Editor training and launch: hands-on training sessions for your content team, editorial guidelines documentation, and go-live with ongoing CMS support."
    },
    "perfOpt": {
      "title": "PERFORMANCE OPTIMIZATION",
      "desc": "Core Web Vitals optimization, image compression, code splitting, lazy loading, and CDN configuration. We guarantee Lighthouse scores above 95 for your website.",
      "longDesc": "Website performance directly impacts your bottom line. Google uses Core Web Vitals as a ranking factor, and research by Deloitte shows that a 0.1-second improvement in load time increases conversion rates by 8.4% for retail sites and 10.1% for travel sites. For European businesses competing for search visibility in markets like Paris, London, or Amsterdam, a slow website is a competitive disadvantage that costs you customers every day. Our performance optimization service identifies and eliminates every bottleneck holding your site back.\n\nWe start with a comprehensive performance audit using Lighthouse, WebPageTest, and Chrome DevTools Performance panel. We test from multiple European locations -- London, Frankfurt, Paris, Amsterdam -- to understand real-world performance for your actual users, not just lab scores from a fast data center. We measure all three Core Web Vitals: Largest Contentful Paint (LCP) measuring how quickly your main content appears, First Input Delay (FID) / Interaction to Next Paint (INP) measuring interactivity responsiveness, and Cumulative Layout Shift (CLS) measuring visual stability. Each metric gets a specific diagnosis and optimization plan.\n\nImage optimization alone typically delivers the biggest performance gains. We convert images to modern formats (WebP for broad compatibility, AVIF for Chrome and Firefox with 30-50% better compression), implement responsive images with srcset and sizes attributes so mobile users do not download desktop-sized images, add explicit width and height attributes to prevent layout shifts, and configure lazy loading with intersection observer so below-the-fold images load only when needed. For sites with many images, we implement a build-time optimization pipeline that processes images automatically.\n\nCode-level optimizations include route-based code splitting so users only download JavaScript for the page they are viewing, tree-shaking to eliminate unused library code, dynamic imports for heavy components (rich text editors, charts, maps), font subsetting to reduce web font file sizes by 60-80%, and critical CSS inlining so above-the-fold content renders without waiting for stylesheets. We also configure HTTP caching headers, Brotli compression, and CDN distribution to serve assets from edge locations close to your European users. Our target: Lighthouse Performance score above 95, LCP under 2 seconds, INP under 200ms, and CLS under 0.05.",
      "f1": "Core Web Vitals audit tested from multiple European locations",
      "f2": "Image optimization with WebP/AVIF conversion and responsive srcsets",
      "f3": "Code splitting, tree-shaking, and dynamic imports for smaller bundles",
      "f4": "Font subsetting and optimized loading with font-display: swap",
      "f5": "Critical CSS inlining for fastest possible above-the-fold rendering",
      "f6": "CDN configuration with Brotli compression and cache optimization",
      "f7": "Lazy loading with intersection observer for images and components",
      "f8": "Performance monitoring dashboard with automated regression alerts",
      "step1": "Performance audit: testing from European locations with Lighthouse, WebPageTest, and real user metrics. Detailed report with prioritized recommendations.",
      "step2": "Quick wins: image optimization, font subsetting, compression configuration, and caching headers. These changes alone typically improve scores by 20-30 points.",
      "step3": "Code optimization: bundle analysis, code splitting, tree-shaking, lazy loading, and critical CSS extraction. Each change is measured for its specific impact.",
      "step4": "Monitoring setup: continuous performance tracking with alerting for regressions, monthly reports, and Core Web Vitals dashboard via Google Search Console."
    },
    "a11y": {
      "title": "ACCESSIBILITY (WCAG)",
      "desc": "WCAG 2.1 AA compliance audits and implementation. Screen reader testing, keyboard navigation, and ARIA landmark optimization for inclusive European web experiences.",
      "longDesc": "Web accessibility is not optional for European businesses -- it is a legal requirement. The European Accessibility Act (EAA), which takes effect in June 2025, requires digital services to meet accessibility standards or face enforcement actions and fines across all EU member states. The UK Equality Act 2010 already requires reasonable adjustments for disabled users. Beyond legal compliance, accessible websites serve the 87 million Europeans with disabilities and benefit all users through better usability, clearer content, and more intuitive navigation. Our accessibility service ensures your website meets WCAG 2.1 AA standards comprehensively.\n\nOur audit process combines automated scanning with expert manual testing. Automated tools like axe-core catch approximately 30-40% of accessibility issues -- missing alt text, insufficient color contrast, missing form labels. The remaining 60-70% require human judgment: whether alt text is actually meaningful, whether the reading order makes sense when navigating by keyboard, whether custom interactive components (dropdowns, modals, carousels) are operable without a mouse, and whether dynamic content changes are announced to screen readers. We test with NVDA on Windows, VoiceOver on macOS and iOS, and TalkBack on Android.\n\nCommon issues we find and fix include: missing or incorrect ARIA roles on custom components, focus traps in modals and overlays, missing skip navigation links, insufficient color contrast ratios (WCAG requires 4.5:1 for normal text, 3:1 for large text), videos without captions or transcripts, forms without proper error messages and labels, touch targets smaller than 44x44 pixels, and content that is only conveyed through color. For each issue, we provide the specific WCAG success criterion it violates, the impact severity, and the exact code fix required.\n\nImplementation goes beyond fixing individual issues. We establish accessible patterns in your component library so new features are accessible by default. This includes keyboard navigation patterns for interactive components, focus management for single-page application route changes, proper heading hierarchy enforcement, responsive text sizing that respects user font-size preferences, and motion reduction for users with vestibular disorders (respecting prefers-reduced-motion). We provide your team with an accessibility checklist and brief training so future development maintains compliance without requiring ongoing audit cycles.",
      "f1": "Comprehensive WCAG 2.1 AA audit with automated and manual testing",
      "f2": "Screen reader testing with NVDA, VoiceOver, and TalkBack",
      "f3": "Keyboard navigation verification for all interactive elements",
      "f4": "Color contrast analysis and remediation for all text elements",
      "f5": "ARIA landmark and role optimization for assistive technology",
      "f6": "Focus management for modals, route changes, and dynamic content",
      "f7": "Accessible form design with proper labels, errors, and instructions",
      "f8": "Accessibility training and documentation for your development team",
      "step1": "Initial audit: automated scanning with axe-core plus manual testing with screen readers and keyboard. Detailed report with severity-ranked issues and WCAG references.",
      "step2": "Remediation: fixing all identified issues in priority order -- critical barriers first, then moderate issues, then enhancements for better usability.",
      "step3": "Component patterns: establishing accessible defaults in your design system so new features inherit proper ARIA roles, focus management, and keyboard behavior.",
      "step4": "Verification and training: re-testing the full site, generating a VPAT/accessibility statement for your website, and training your team on maintaining compliance."
    },
    "gdpr": {
      "title": "GDPR COMPLIANCE",
      "desc": "Cookie consent implementation, privacy policies, data processing agreements, and compliant contact forms. Full GDPR and ePrivacy Directive compliance for EU-operating websites.",
      "longDesc": "GDPR compliance for websites is not just about adding a cookie banner -- it is a comprehensive approach to data protection that European regulators actively enforce. Fines under GDPR can reach EUR 20 million or 4% of global turnover, and enforcement has intensified significantly since 2022 with the French CNIL, German BfDI, and Dutch AP issuing penalties to businesses of all sizes. Our GDPR compliance service ensures your website handles personal data correctly, from the moment a visitor loads your page to the point their data is deleted.\n\nCookie consent is the most visible compliance requirement and the one most websites get wrong. We implement Consent Mode v2 with Google Tag Manager, which is required for running Google Ads in the EU since March 2024. Our implementation blocks all non-essential cookies and scripts until the user gives explicit consent, provides granular options (analytics, marketing, functional cookies as separate categories), stores consent proof with timestamp and user agent for audit purposes, and re-requests consent when your cookie policy changes. The consent banner adapts per country -- Germany requires strict opt-in while some other jurisdictions accept implied consent for analytics.\n\nBeyond cookies, we ensure your data collection points are fully compliant. Contact forms include explicit consent checkboxes with links to your privacy policy. Newsletter signups use double opt-in (required in Germany under UWG). File uploads are scanned and stored securely with access controls. Your privacy policy is written in plain language (GDPR Article 12 requires clear communication), covers all required disclosures including data retention periods, third-party processors, international transfers, and user rights, and is available in all languages your website supports.\n\nWe also implement the technical infrastructure for data subject rights. Users have the right to access their data, request corrections, demand deletion, and export their data in a portable format. We build these capabilities into your application: a self-service data export function, account deletion workflows that cascade through all data stores, and audit logging that records who accessed personal data and when. For businesses using Supabase, we configure row-level security policies that enforce data isolation between users and implement automatic data retention policies that delete inactive user data after your specified retention period.",
      "f1": "Consent Mode v2 cookie banner with granular category controls",
      "f2": "Google Tag Manager integration blocking scripts until consent is given",
      "f3": "Privacy policy and cookie policy drafted in plain language, all languages",
      "f4": "Double opt-in for newsletters compliant with German UWG requirements",
      "f5": "Data subject rights: self-service access, export, correction, and deletion",
      "f6": "Data Processing Agreement templates for your third-party processors",
      "f7": "Consent proof storage with timestamps for regulatory audit readiness",
      "f8": "Automatic data retention policies with scheduled deletion workflows",
      "step1": "Data mapping: identifying every personal data collection point on your website -- forms, cookies, analytics, third-party scripts -- and documenting data flows.",
      "step2": "Implementation: cookie consent banner, privacy policies, form consent mechanisms, and Google Tag Manager consent mode configuration across all pages.",
      "step3": "Technical controls: data subject rights workflows, consent proof storage, data retention automation, and row-level security for multi-user applications.",
      "step4": "Documentation and audit: GDPR compliance documentation, Data Processing Agreement templates, staff guidance, and optional Data Protection Officer consultation."
    },
    "integrations": {
      "title": "THIRD-PARTY INTEGRATIONS",
      "desc": "CRM, payment gateway, analytics, email marketing, and social media API integrations. Connect your website to the tools your European business already relies on.",
      "longDesc": "Modern businesses run on interconnected tools, and your website should be the hub that connects them all. We integrate your website with CRMs like HubSpot, Salesforce, and Pipedrive so leads from contact forms flow directly into your sales pipeline. We connect payment processors like Stripe, Mollie, and Adyen for seamless European transactions. We wire up email marketing platforms like Mailchimp, Brevo (formerly Sendinblue), and ConvertKit so newsletter signups trigger automated welcome sequences. Every integration is built to be reliable, secure, and maintainable.\n\nOur integration approach prioritizes official APIs and webhooks over fragile screen-scraping or unofficial methods. We build abstraction layers between your application and third-party services, so if you decide to switch from HubSpot to Pipedrive or from Mailchimp to Brevo, only the integration adapter changes -- your application logic remains untouched. Error handling includes automatic retries with exponential backoff for transient failures, dead letter queues for messages that cannot be processed, and alerting when an integration fails repeatedly.\n\nFor European businesses, payment integration requires special attention. We integrate with Stripe for card payments across all European markets, Mollie for Dutch-specific methods (iDEAL, Bancontact), Klarna for buy-now-pay-later in Scandinavia and Germany, SEPA Direct Debit for recurring B2B payments, and Adyen for enterprise-grade multi-currency processing. Each payment integration includes proper PSD2 Strong Customer Authentication (SCA), 3D Secure handling, and VAT calculation based on the customer's country -- requirements that many non-European developers overlook.\n\nAnalytics integrations go beyond basic Google Analytics installation. We implement server-side tracking with Google Analytics 4 Measurement Protocol for accurate conversion data unaffected by ad blockers, Microsoft Clarity for session recordings and heatmaps, and custom event tracking that maps to your business KPIs (not just page views). For clients running paid advertising, we set up conversion APIs for Meta (Facebook), Google Ads, and LinkedIn that send server-side conversion data, improving attribution accuracy by 20-30% compared to browser-only tracking. All analytics implementations respect cookie consent through Consent Mode v2 integration.",
      "f1": "CRM integration with HubSpot, Salesforce, or Pipedrive for lead capture",
      "f2": "European payment processors: Stripe, Mollie, Klarna, and SEPA Direct Debit",
      "f3": "Email marketing: Mailchimp, Brevo, or ConvertKit with automated workflows",
      "f4": "Google Analytics 4 with server-side tracking and Consent Mode v2",
      "f5": "Social media APIs: Meta Conversion API, LinkedIn, and Google Ads",
      "f6": "Calendar booking integrations with Cal.com, Calendly, or Acuity",
      "f7": "Accounting software integration with Xero, QuickBooks, or Exact Online",
      "f8": "Custom webhook workflows connecting any API-enabled business tool",
      "step1": "Integration audit: cataloging your existing tools, APIs, and data flows. Identifying which integrations deliver the most business value and prioritizing them.",
      "step2": "Architecture design: defining data mapping between systems, webhook flows, error handling strategy, and fallback behavior for each integration.",
      "step3": "Implementation and testing: building each integration with proper authentication, error handling, retry logic, and end-to-end testing with real data.",
      "step4": "Deployment and monitoring: going live with integration monitoring, error alerting, and documentation for your team on managing each connected service."
    }
  },
  "faq": {
    "reactDev1Q": "Why choose React over other JavaScript frameworks?",
    "reactDev1A": "React has the largest ecosystem, most extensive library support, and strongest job market of any frontend framework. Its component model encourages reusability, and the virtual DOM delivers excellent rendering performance. For European businesses, this means more available developers for future maintenance and a vast ecosystem of proven solutions.",
    "reactDev2Q": "Can you migrate our existing website to React?",
    "reactDev2A": "Yes, we regularly migrate sites from WordPress, jQuery, Angular, and vanilla HTML to React. We use an incremental migration strategy that keeps your existing site running while building the React replacement section by section, ensuring zero downtime and preserved SEO rankings throughout the transition.",
    "reactDev3Q": "How do you handle state management in React applications?",
    "reactDev3A": "For most projects, we use Zustand -- a lightweight, TypeScript-friendly state manager that avoids Redux boilerplate. For simpler cases, React Context suffices. For server state, we use TanStack Query for caching and synchronization. The choice depends on your application's complexity and data patterns.",
    "reactDev4Q": "Do React applications work well for SEO?",
    "reactDev4A": "Client-side React requires server-side rendering or static generation for optimal SEO. We implement SSR with Next.js or pre-rendering with Vite for search engine visibility. Meta tags, structured data, and sitemap generation are configured for every page to maximize search engine indexing.",
    "nextjsDev1Q": "What is the difference between Next.js and plain React?",
    "nextjsDev1A": "Next.js adds server-side rendering, static generation, API routes, file-based routing, and image optimization on top of React. For SEO-dependent sites like business websites and e-commerce stores, Next.js delivers significantly better search visibility because Google can index fully rendered content without executing JavaScript.",
    "nextjsDev2Q": "Is Next.js suitable for large-scale enterprise applications?",
    "nextjsDev2A": "Absolutely. Companies like Netflix, Twitch, and Nike use Next.js in production. Its hybrid rendering model, middleware system, and edge functions handle enterprise-scale traffic efficiently. We architect Next.js applications with proper caching layers and database connection pooling for high-concurrency European business applications.",
    "nextjsDev3Q": "How does incremental static regeneration (ISR) work?",
    "nextjsDev3A": "ISR lets you update static pages without rebuilding the entire site. When a page is requested after its revalidation period, Next.js serves the cached version instantly while regenerating the page in the background. Your users always see fast responses, and content stays fresh within your configured timeframe.",
    "nextjsDev4Q": "Can Next.js handle multilingual websites for European markets?",
    "nextjsDev4A": "Next.js has built-in internationalized routing that supports locale-prefixed URLs, automatic locale detection, and domain-based routing. We combine this with i18next for content translation and proper hreflang implementation, ensuring each language version is correctly indexed by Google for its target market.",
    "typescriptDev1Q": "Does TypeScript slow down development compared to JavaScript?",
    "typescriptDev1A": "Initially, TypeScript adds a small overhead as you define types. However, it significantly speeds up long-term development by catching bugs at compile time, enabling confident refactoring, and providing IntelliSense autocomplete that reduces time spent reading documentation. Projects longer than two months consistently benefit from TypeScript.",
    "typescriptDev2Q": "Can you add TypeScript to our existing JavaScript project?",
    "typescriptDev2A": "Yes, TypeScript can be adopted incrementally. We start by renaming files from .js to .ts and adding strict mode gradually. Critical modules get typed first, then we expand coverage over time. This approach lets your team continue shipping features while the codebase improves progressively.",
    "typescriptDev3Q": "What TypeScript strict mode options do you enable?",
    "typescriptDev3A": "We enable all strict mode flags: strictNullChecks (preventing null reference errors), noImplicitAny (requiring explicit types), strictFunctionTypes, strictBindCallApply, and noUncheckedIndexedAccess. These catch the most common runtime errors at compile time and are essential for production-grade applications.",
    "typescriptDev4Q": "How does TypeScript integrate with your testing approach?",
    "typescriptDev4A": "TypeScript pairs excellently with our testing stack. Vitest runs TypeScript tests natively without separate compilation. Type-safe test utilities from React Testing Library ensure test props match component interfaces. Zod schemas validate runtime data while TypeScript verifies compile-time contracts, providing two layers of type safety.",
    "frontendDev1Q": "What is your approach to responsive design?",
    "frontendDev1A": "We follow a mobile-first methodology, designing for 320px screens first and progressively enhancing for larger viewports. We use CSS clamp() for fluid typography, CSS Grid for complex layouts, and test on real devices -- not just browser simulators. Every interactive element meets the WCAG 44x44px minimum touch target requirement.",
    "frontendDev2Q": "How do you ensure frontend performance on slower connections?",
    "frontendDev2A": "We test on throttled 3G connections to simulate real-world European mobile networks. Techniques include code splitting to load only necessary JavaScript, lazy loading for below-the-fold content, modern image formats (WebP, AVIF) with responsive srcsets, and font subsetting. Our target is LCP under 2 seconds on 4G.",
    "frontendDev3Q": "Do you support older browsers like Internet Explorer?",
    "frontendDev3A": "Internet Explorer usage in Europe is below 0.5%, so we do not support it. We support the last two versions of Chrome, Firefox, Safari, and Edge, which covers over 97% of European users. If your analytics show specific browser needs, we can adjust our browser support matrix accordingly.",
    "frontendDev4Q": "How do you handle frontend accessibility?",
    "frontendDev4A": "Accessibility is built into our development process from the start. We use semantic HTML, ARIA attributes where needed, keyboard navigation support, and screen reader testing with NVDA and VoiceOver. Every component in our design system meets WCAG 2.1 AA standards, and we run automated accessibility checks in CI.",
    "customApps1Q": "How long does it take to build a custom web application?",
    "customApps1A": "A simple dashboard or portal takes 4-8 weeks. A mid-complexity application with authentication, roles, and integrations takes 8-16 weeks. Complex SaaS platforms can take 16-24 weeks. We deliver working increments every two weeks so you see progress and can provide feedback early and often.",
    "customApps2Q": "What backend technology do you use for custom applications?",
    "customApps2A": "Our primary backend is Supabase, providing PostgreSQL, real-time subscriptions, authentication, storage, and edge functions. For complex business logic, we add Node.js microservices. This combination delivers enterprise-grade capabilities without the cost and complexity of traditional backend infrastructure.",
    "customApps3Q": "How do you handle data security in custom applications?",
    "customApps3A": "Security is built into every layer: row-level security in PostgreSQL, JWT authentication with refresh token rotation, input validation with Zod schemas, rate limiting on all endpoints, and encryption in transit and at rest. We follow OWASP security guidelines and conduct security reviews before every production deployment.",
    "customApps4Q": "Can you integrate with our existing business systems?",
    "customApps4A": "Yes, we build API integrations with CRMs (HubSpot, Salesforce), accounting software (Xero, QuickBooks), ERP systems, and any tool with a REST or GraphQL API. We design integration layers with proper error handling and retry logic so your systems stay synchronized reliably.",
    "pwa1Q": "What is the difference between a PWA and a native mobile app?",
    "pwa1A": "PWAs are accessed via browser and can be installed to the home screen without app stores. They work offline, send push notifications, and access device APIs. Unlike native apps, PWAs have a single codebase for all platforms and avoid Apple's 30% commission. The tradeoff is limited access to some device-specific features like Bluetooth.",
    "pwa2Q": "Do PWAs work on iOS and Safari?",
    "pwa2A": "Yes. Safari supports PWA features including service workers, web app manifest, and push notifications (since iOS 16.4). Some features like background sync have limitations compared to Android. We design PWAs that provide the best experience on each platform while gracefully handling these differences.",
    "pwa3Q": "How does offline functionality work in a PWA?",
    "pwa3A": "Service workers cache your application shell, key pages, and API responses. When the user goes offline, cached content loads instantly. Data entered offline is stored locally and synchronized with the server when connectivity returns via background sync. We configure caching strategies per resource type for optimal freshness.",
    "pwa4Q": "Can a PWA replace our planned native app?",
    "pwa4A": "For many European business use cases -- content delivery, forms, booking systems, basic e-commerce -- a PWA delivers 90% of native app functionality at 30-50% of the development cost. We assess your specific feature requirements and honestly recommend native development only when PWA capabilities are genuinely insufficient.",
    "apiDev1Q": "Should we choose REST or GraphQL for our API?",
    "apiDev1A": "REST is simpler and ideal for straightforward CRUD operations with well-defined resources. GraphQL excels when your frontend needs flexible data queries, multiple related resources in one request, or real-time subscriptions. We recommend REST for most European business applications and GraphQL for complex data-driven dashboards.",
    "apiDev2Q": "How do you secure API endpoints?",
    "apiDev2A": "Every endpoint uses JWT authentication with short-lived access tokens and secure refresh token rotation. We implement rate limiting per user and per IP, input validation with Zod schemas, CORS policies restricted to your domains, and request logging for audit trails. For sensitive operations, we add two-factor verification.",
    "apiDev3Q": "Can you build APIs that integrate with our mobile app?",
    "apiDev3A": "Absolutely. We design APIs with mobile clients in mind: paginated responses for bandwidth efficiency, field selection to reduce payload sizes, proper HTTP caching headers, and optimistic update patterns. Our OpenAPI documentation and generated TypeScript SDKs make integration straightforward for your mobile development team.",
    "apiDev4Q": "How do you handle API versioning?",
    "apiDev4A": "We use URL-based versioning (v1/v2) for public APIs because it is explicit and easy for consumers to understand. For internal APIs, we prefer additive changes that maintain backward compatibility. When breaking changes are unavoidable, we maintain the previous version for a defined deprecation period with clear migration documentation.",
    "redesign1Q": "Will a redesign affect our current Google rankings?",
    "redesign1A": "When done correctly, a redesign should improve your rankings. We create comprehensive 301 redirect maps, preserve existing URL structures where possible, maintain or improve content quality, and monitor Search Console closely post-launch. Our migration checklist covers 87 items specifically to prevent traffic loss during the transition.",
    "redesign2Q": "How long does a website redesign typically take?",
    "redesign2A": "A small business site (5-10 pages) takes 3-5 weeks including the audit phase. A larger site with 20+ pages, e-commerce, or complex functionality takes 6-12 weeks. We always begin with a two-week audit and strategy phase to ensure the redesign is driven by data rather than assumptions.",
    "redesign3Q": "Can we keep our current CMS during a redesign?",
    "redesign3A": "If your current CMS works well for your editors, we can use it as a headless backend and build a modern React frontend that consumes its content via API. This gives you a fast new website without requiring your team to learn a new content management system. WordPress to headless is our most common migration path.",
    "redesign4Q": "What if our current site is on WordPress -- can you still redesign it?",
    "redesign4A": "Yes, WordPress redesigns are our most frequent project type. We either build a custom React frontend using WordPress as a headless CMS, or migrate content entirely to a modern stack like Next.js with Payload CMS. The approach depends on your team's comfort with content management and your long-term technology goals.",
    "legacyMod1Q": "How do you handle data migration from legacy systems?",
    "legacyMod1A": "We build automated migration scripts that extract data from your legacy system, transform it to match the new schema, and load it into the new database. Every migration runs through a validation pipeline that compares record counts, checksums, and sample data. We perform test migrations before the real cutover.",
    "legacyMod2Q": "Can you modernize our site without downtime?",
    "legacyMod2A": "Yes, we use the strangler fig pattern: the new application is built alongside the old one, and traffic is shifted gradually page by page. At no point does your website go offline. When all pages have migrated, we decommission the legacy system. This approach also lets us verify each section works correctly before moving to the next.",
    "legacyMod3Q": "Our WordPress site has 200 blog posts -- can you migrate all content?",
    "legacyMod3A": "Absolutely. We use the WordPress REST API or WPGraphQL to export all posts, pages, media, and metadata programmatically. Content is transformed, images are re-optimized, and internal links are updated. We verify every piece of content migrates correctly with automated comparison checks.",
    "legacyMod4Q": "Is it worth modernizing or should we rebuild from scratch?",
    "legacyMod4A": "It depends on your existing codebase quality and business logic complexity. Simple marketing sites are faster to rebuild. Applications with complex business logic often benefit from incremental modernization, preserving validated business rules while upgrading the technology layer. We assess your specific situation and recommend honestly.",
    "maintenance1Q": "What does your monthly care plan include?",
    "maintenance1A": "Our EUR 97/month care plan includes weekly dependency updates, monthly security scans, uptime monitoring with alerts, daily automated backups, content updates within one business day, monthly performance reports, priority support with 4-hour response time, and quarterly strategy reviews with optimization recommendations.",
    "maintenance2Q": "How quickly do you respond to urgent issues?",
    "maintenance2A": "Care plan clients get priority support with a 4-hour response time guarantee during business hours (9:00-18:00 CET). For critical issues like site downtime or security breaches, we provide emergency response within one hour. Non-urgent requests are addressed within one business day.",
    "maintenance3Q": "Can you maintain a website that someone else built?",
    "maintenance3A": "Yes, we maintain sites built by other agencies or developers, provided the codebase is in a modern framework we support (React, Next.js, Vue, or standard HTML/CSS). We begin with a codebase audit to understand the architecture, identify technical debt, and establish a baseline before starting regular maintenance.",
    "maintenance4Q": "What happens if we want to cancel the care plan?",
    "maintenance4A": "Our care plans require a 30-day notice to cancel. Upon cancellation, we provide full access to all source code, hosting credentials, and documentation. We also offer a transition period where we brief your new developer or agency on the codebase architecture and ongoing maintenance requirements.",
    "headlessCms1Q": "What is a headless CMS and why should we use one?",
    "headlessCms1A": "A headless CMS manages your content (text, images, structured data) and delivers it via API, while a separate frontend application renders it for users. This decoupled approach lets editors use a familiar interface while developers build fast, modern frontends. It also enables content reuse across websites, apps, and other channels.",
    "headlessCms2Q": "Why do you recommend Payload CMS over Contentful or Sanity?",
    "headlessCms2A": "Payload CMS is open-source and self-hosted, meaning no per-seat fees, no API call limits, and full control over your data. For European businesses with data sovereignty requirements, self-hosting in an EU data center ensures GDPR compliance. Payload is built with TypeScript, providing type-safe content queries that prevent runtime errors.",
    "headlessCms3Q": "Will our editors find a headless CMS difficult to use?",
    "headlessCms3A": "Not with Payload CMS. Its admin panel is intuitive -- similar to WordPress but more organized. Editors create and update content through a clean interface with rich text editing, media management, and live preview. We provide hands-on training and create editorial guidelines specific to your content structure.",
    "headlessCms4Q": "Can we preview content changes before publishing?",
    "headlessCms4A": "Yes. We set up draft mode and live preview so editors can see exactly how their changes will appear on the actual website before publishing. Payload CMS supports draft/publish workflows with version history, so editors can save drafts, preview them, request reviews, and roll back to previous versions if needed.",
    "perfOpt1Q": "What Lighthouse score can we realistically achieve?",
    "perfOpt1A": "For modern React or Next.js sites, we consistently achieve 95+ on Performance, Accessibility, Best Practices, and SEO. Sites with heavy third-party scripts (chat widgets, analytics, ads) may score 85-95 on Performance due to external script overhead. We optimize what we control and advise on third-party script impact.",
    "perfOpt2Q": "How much can performance optimization improve our conversion rate?",
    "perfOpt2A": "Research by Google and Deloitte shows that each 0.1-second improvement in load time increases conversions by 8-10% for retail and travel sites. For a typical European business site, our optimizations reduce load time by 1-3 seconds, which translates to measurable improvements in bounce rate, time on site, and form completions.",
    "perfOpt3Q": "Do you optimize for Core Web Vitals specifically?",
    "perfOpt3A": "Yes, Core Web Vitals are our primary performance targets. We optimize LCP (Largest Contentful Paint) to under 2 seconds, INP (Interaction to Next Paint) to under 200ms, and CLS (Cumulative Layout Shift) to under 0.05. These metrics directly affect Google rankings and are measured from real user data in Search Console.",
    "perfOpt4Q": "Can you optimize a WordPress site's performance?",
    "perfOpt4A": "We can improve WordPress performance through caching plugins, image optimization, database cleanup, and CDN configuration. However, WordPress has inherent performance limitations due to its PHP architecture and plugin system. For maximum performance, we recommend migrating to a modern React or Next.js stack.",
    "a11y1Q": "Is web accessibility legally required in Europe?",
    "a11y1A": "Yes. The European Accessibility Act (EAA) requires digital services to meet accessibility standards from June 2025 across all EU member states. The UK Equality Act 2010 already mandates reasonable adjustments for disabled users. Non-compliance carries financial penalties and legal liability in most European jurisdictions.",
    "a11y2Q": "What does WCAG 2.1 AA compliance actually require?",
    "a11y2A": "WCAG 2.1 AA requires perceivable content (text alternatives, captions, sufficient contrast), operable interfaces (keyboard accessible, no seizure-inducing content, sufficient time), understandable content (readable, predictable, input assistance), and robust markup (compatible with assistive technologies). It covers 50 specific success criteria.",
    "a11y3Q": "How long does an accessibility audit take?",
    "a11y3A": "A comprehensive audit of a 10-20 page website takes 5-7 business days. This includes automated scanning, manual keyboard and screen reader testing across three screen readers, detailed reporting with severity ratings, and specific remediation instructions for each issue. Larger sites or web applications take proportionally longer.",
    "a11y4Q": "Can you make our existing website accessible without a full redesign?",
    "a11y4A": "In most cases, yes. Common fixes like adding alt text, improving color contrast, adding ARIA labels, and fixing keyboard navigation can be implemented within your existing codebase. Only sites with fundamental structural issues (like content embedded in images or Flash-based interfaces) require a more extensive rebuild.",
    "gdpr1Q": "What does GDPR compliance require for a business website?",
    "gdpr1A": "At minimum: a cookie consent banner that blocks non-essential cookies until consent, a comprehensive privacy policy, explicit consent checkboxes on forms, data processing agreements with third-party tools, and the ability to handle data subject requests (access, deletion, portability). The specifics vary by country and the data you collect.",
    "gdpr2Q": "Is a simple cookie banner enough for GDPR compliance?",
    "gdpr2A": "No. A compliant cookie banner must block all non-essential scripts before consent, offer granular category choices (not just accept/reject), store consent proof with timestamps, and allow users to change their preferences. Many popular cookie banner solutions are not actually compliant. We implement Consent Mode v2 which meets the strictest EU requirements.",
    "gdpr3Q": "Do we need a Data Protection Officer (DPO)?",
    "gdpr3A": "GDPR requires a DPO for public authorities, organizations processing data at scale, or those handling sensitive data categories. Most small to medium European businesses do not need a formal DPO, but they do need someone responsible for data protection. We can advise on your specific obligation and connect you with DPO consultants if needed.",
    "gdpr4Q": "How do you handle GDPR for multilingual websites?",
    "gdpr4A": "Privacy policies and cookie consent must be available in every language your website supports. We draft legally compliant policies in English, French, Dutch, and German, adapting to country-specific requirements (German UWG requires double opt-in for newsletters, French CNIL has specific cookie guidelines). Each language version references the applicable local regulations.",
    "integrations1Q": "Which CRM systems can you integrate with our website?",
    "integrations1A": "We integrate with HubSpot (most popular for European SMEs), Salesforce (enterprise), Pipedrive (sales-focused), and Zoho CRM. We connect your website forms to create CRM contacts automatically, trigger follow-up sequences, and sync customer data. Any CRM with a REST API or webhook support can be integrated.",
    "integrations2Q": "How do you handle European payment methods beyond credit cards?",
    "integrations2A": "We integrate local payment methods that European customers prefer: iDEAL for the Netherlands (60% of online payments), Bancontact for Belgium, Klarna for Scandinavia and Germany, SEPA Direct Debit for B2B recurring payments, and Giropay for Germany. Stripe and Mollie serve as our primary payment processors for multi-method support.",
    "integrations3Q": "Can you integrate analytics while respecting GDPR cookie consent?",
    "integrations3A": "Yes, we implement Google Analytics 4 with Consent Mode v2, which collects modeled data even when users decline cookies. Server-side tracking via the GA4 Measurement Protocol provides accurate conversion data unaffected by ad blockers. All analytics scripts are blocked until the user gives explicit consent through our compliant cookie banner.",
    "integrations4Q": "How long does a typical integration project take?",
    "integrations4A": "A single integration (e.g., CRM form connection) takes 2-3 business days. A package of 3-5 integrations (CRM, payment, email marketing, analytics) takes 2-3 weeks. Complex integrations with custom data transformations or bi-directional sync take 3-5 weeks. We scope each integration individually during the discovery phase."
  }
}
